<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>FreeModbus: AT91SAM7X_ROWLEY/demo.c</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>

<!-- Generated by Doxygen 1.4.2 -->
<h1>AT91SAM7X_ROWLEY/demo.c</h1><div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * FreeModbus Libary: ARM7 Demo Application</span>
<span class="comment"> * Copyright (C) 2006 Christian Walter &lt;wolti@sil.at&gt;</span>
<span class="comment"> *</span>
<span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="comment"> * (at your option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment"> * GNU General Public License for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU General Public License</span>
<span class="comment"> * along with this program; if not, write to the Free Software</span>
<span class="comment"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="comment"> *</span>
<span class="comment"> * File: $Id$</span>
<span class="comment"> */</span>

<span class="comment">/* ----------------------- System includes ----------------------------------*/</span>
<span class="preprocessor">#include "assert.h"</span>

<span class="comment">/* ----------------------- Platform includes --------------------------------*/</span>
<span class="preprocessor">#include "support/AT91SAM7X256.h"</span>
<span class="preprocessor">#include "support/lib_AT91SAM7X256.h"</span>

<span class="preprocessor">#include "FreeRTOS.h"</span>
<span class="preprocessor">#include "task.h"</span>
<span class="preprocessor">#include "queue.h"</span>

<span class="comment">/* ----------------------- Modbus includes ----------------------------------*/</span>
<span class="preprocessor">#include "mb.h"</span>

<span class="comment">/* ----------------------- Defines ------------------------------------------*/</span>
<span class="preprocessor">#define REG_HOLDING_START           0x1000</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_HOLDING_NREGS           130</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_INPUT_START             0x1000</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_INPUT_NREGS             4</span>
<span class="preprocessor"></span>
<span class="comment">/* ----------------------- Static variables ---------------------------------*/</span>
<span class="keyword">static</span> USHORT   usRegHoldingStart = REG_HOLDING_START;
<span class="keyword">static</span> USHORT   usRegHoldingBuf[REG_HOLDING_NREGS];
<span class="keyword">static</span> USHORT   usRegInputStart = REG_INPUT_START;
<span class="keyword">static</span> USHORT   usRegInputBuf[REG_INPUT_NREGS];

<span class="comment">/* ----------------------- Static functions ---------------------------------*/</span>
STATIC <span class="keywordtype">void</span>     vModbusTask( <span class="keywordtype">void</span> *pvParameters );
STATIC <span class="keywordtype">void</span>     vSetupHardware( <span class="keywordtype">void</span> );

<span class="comment">/* ----------------------- Start implementation -----------------------------*/</span>
<span class="keywordtype">int</span>
main( <span class="keywordtype">void</span> )
{
    vSetupHardware(  );

    ( void )xTaskCreate( vModbusTask, NULL, configMINIMAL_STACK_SIZE, NULL,
                         tskIDLE_PRIORITY, NULL );

    vTaskStartScheduler(  );
    <span class="keywordflow">return</span> 0;
}

<span class="keyword">static</span> <span class="keywordtype">void</span>
vModbusTask( <span class="keywordtype">void</span> *pvParameters )
{
    <span class="keywordtype">int</span>             i;

    <span class="comment">/* Select either ASCII or RTU Mode. */</span>
    ( void )<a name="a0"></a><a class="code" href="group__modbus.html#ga0">eMBInit</a>( <a name="a1"></a><a class="code" href="group__modbus.html#gga9a1">MB_RTU</a>, 0x0A, 0, 38400, <a name="a2"></a><a class="code" href="group__modbus.html#gga12a9">MB_PAR_EVEN</a> );

    <span class="comment">/* Initialize the holding register values before starting the</span>
<span class="comment">     * Modbus stack</span>
<span class="comment">     */</span>
    <span class="keywordflow">for</span>( i = 0; i &lt; REG_HOLDING_NREGS; i++ )
    {
        usRegHoldingBuf[i] = ( <span class="keywordtype">unsigned</span> short )i;
    }
    <span class="comment">/* Initialize the input register values before starting the</span>
<span class="comment">     * Modbus stack</span>
<span class="comment">     */</span>
    <span class="keywordflow">for</span>( i = 0; i &lt; REG_INPUT_NREGS; i++ )
    {
        usRegInputBuf[i] = ( <span class="keywordtype">unsigned</span> short )i;
    }

    <span class="comment">/* Enable the Modbus Protocol Stack. */</span>
    ( void )<a name="a3"></a><a class="code" href="group__modbus.html#ga3">eMBEnable</a>(  );
    <span class="keywordflow">for</span>( ;; )
    {
        <span class="comment">/* Call the main polling loop of the Modbus protocol stack. */</span>
        ( void )<a name="a4"></a><a class="code" href="group__modbus.html#ga5">eMBPoll</a>(  );
    }
}

<a name="a5"></a><a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a6"></a><a class="code" href="group__modbus__registers.html#ga0">eMBRegInputCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
    <a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    eStatus = <a name="a7"></a><a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a>;
    <span class="keywordtype">int</span>             iRegIndex;

    <span class="keywordflow">if</span>( ( usAddress &gt;= REG_INPUT_START )
        &amp;&amp; ( usAddress + usNRegs &lt;= REG_INPUT_START + REG_INPUT_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegInputStart );
        <span class="keywordflow">while</span>( usNRegs &gt; 0 )
        {
            *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegInputBuf[iRegIndex] &gt;&gt; 8 );
            *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegInputBuf[iRegIndex] &amp; 0xFF );
            iRegIndex++;
            usNRegs--;
        }
    }
    <span class="keywordflow">else</span>
    {
        eStatus = <a name="a8"></a><a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
    }

    <span class="keywordflow">return</span> eStatus;
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a9"></a><a class="code" href="group__modbus__registers.html#ga1">eMBRegHoldingCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, <a name="a10"></a><a class="code" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode )
{
    <a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    eStatus = <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a>;
    <span class="keywordtype">int</span>             iRegIndex;

    <span class="keywordflow">if</span>( ( usAddress &gt;= REG_HOLDING_START ) &amp;&amp;
        ( usAddress + usNRegs &lt;= REG_HOLDING_START + REG_HOLDING_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegHoldingStart );
        <span class="keywordflow">switch</span> ( eMode )
        {
            <span class="comment">/* Pass current register values to the protocol stack. */</span>
        <span class="keywordflow">case</span> <a name="a11"></a><a class="code" href="group__modbus.html#gga10a4">MB_REG_READ</a>:
            <span class="keywordflow">while</span>( usNRegs &gt; 0 )
            {
                *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegHoldingBuf[iRegIndex] &gt;&gt; 8 );
                *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegHoldingBuf[iRegIndex] &amp; 0xFF );
                iRegIndex++;
                usNRegs--;
            }
            <span class="keywordflow">break</span>;

            <span class="comment">/* Update current register values with new values from the</span>
<span class="comment">             * protocol stack. */</span>
        <span class="keywordflow">case</span> <a name="a12"></a><a class="code" href="group__modbus.html#gga10a5">MB_REG_WRITE</a>:
            <span class="keywordflow">while</span>( usNRegs &gt; 0 )
            {
                usRegHoldingBuf[iRegIndex] = *pucRegBuffer++ &lt;&lt; 8;
                usRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
                iRegIndex++;
                usNRegs--;
            }
        }
    }
    <span class="keywordflow">else</span>
    {
        eStatus = <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
    }
    <span class="keywordflow">return</span> eStatus;
}


<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a13"></a><a class="code" href="group__modbus__registers.html#ga2">eMBRegCoilsCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, <a class="code" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode )
{
    <span class="keywordflow">return</span> <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a14"></a><a class="code" href="group__modbus__registers.html#ga3">eMBRegDiscreteCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
    <span class="keywordflow">return</span> <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
}


<span class="keywordtype">void</span>
vSetupHardware( <span class="keywordtype">void</span> )
{
    vMBPInit(  );

    <span class="comment">/* Enable the peripheral clock. */</span>
    AT91C_BASE_PMC-&gt;PMC_PCER = 1 &lt;&lt; AT91C_ID_PIOA;
    AT91C_BASE_PMC-&gt;PMC_PCER = 1 &lt;&lt; AT91C_ID_PIOB;
}
</pre></div> 
<hr width="80%">
<p><center>Automatically generated by Doxygen 1.4.2 on 13 Sep 2018.</center></p>

</body>
</html>
