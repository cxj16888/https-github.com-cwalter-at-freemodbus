<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>FreeModbus: Modbus Registers</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>

<!-- Generated by Doxygen 1.4.2 -->
<h1>Modbus Registers</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "mb.h"</span> 
</pre></div> The protocol stack does not internally allocate any memory for the registers. This makes the protocol stack very small and also usable on low end targets. In addition the values don't have to be in the memory and could for example be stored in a flash.<br>
 Whenever the protocol stack requires a value it calls one of the callback function with the register address and the number of registers to read as an argument. The application should then read the actual register values (for example the ADC voltage) and should store the result in the supplied buffer.<br>
 If the protocol stack wants to update a register value because a write register function was received a buffer with the new register values is passed to the callback function. The function should then use these values to update the application register values. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus__registers.html#ga0">eMBRegInputCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNRegs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus__registers.html#ga1">eMBRegHoldingCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNRegs, <a class="el" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus__registers.html#ga2">eMBRegCoilsCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNCoils, <a class="el" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus__registers.html#ga3">eMBRegDiscreteCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNDiscrete)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga2" doxytag="mb.h::eMBRegCoilsCB"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBRegCoilsCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">UCHAR *&nbsp;</td>
          <td class="mdname" nowrap> <em>pucRegBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>USHORT&nbsp;</td>
          <td class="mdname" nowrap> <em>usAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>USHORT&nbsp;</td>
          <td class="mdname" nowrap> <em>usNCoils</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__modbus.html#ga10">eMBRegisterMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>eMode</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback function used if a <em>Coil Register</em> value is read or written by the protocol stack. If you are going to use this function you might use the functions <a class="el" href="group__modbus__utils.html#ga0">xMBUtilSetBits(  )</a> and <a class="el" href="group__modbus__utils.html#ga1">xMBUtilGetBits(  )</a> for working with bitfields. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pucRegBuffer</em>&nbsp;</td><td>The bits are packed in bytes where the first coil starting at address <code>usAddress</code> is stored in the LSB of the first byte in the buffer <code>pucRegBuffer</code>. If the buffer should be written by the callback function unused coil values (I.e. if not a multiple of eight coils is used) should be set to zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usAddress</em>&nbsp;</td><td>The first coil number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usNCoils</em>&nbsp;</td><td>Number of coil values requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eMode</em>&nbsp;</td><td>If <a class="el" href="group__modbus.html#gga10a5">eMBRegisterMode::MB_REG_WRITE</a> the application values should be updated from the values supplied in the buffer <code>pucRegBuffer</code>. If <a class="el" href="group__modbus.html#gga10a4">eMBRegisterMode::MB_REG_READ</a> the application should store the current values in the buffer <code>pucRegBuffer</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The function must return one of the following error codes:<ul>
<li><a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a> If no error occurred. In this case a normal Modbus response is sent.</li><li><a class="el" href="group__modbus.html#gga11a7">eMBErrorCode::MB_ENOREG</a> If the application does not map an coils within the requested address range. In this case a <b>ILLEGAL DATA ADDRESS</b> is sent as a response.</li><li><a class="el" href="group__modbus.html#gga11a13">eMBErrorCode::MB_ETIMEDOUT</a> If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li><li><a class="el" href="group__modbus.html#gga11a11">eMBErrorCode::MB_EIO</a> If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li></ul>
</dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AT91SAM7X__ROWLEY_2demo_8c-example.html#a13">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a27">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a45">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a59">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a75">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a90">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a103">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a119">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a137">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a153">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="mb.h::eMBRegDiscreteCB"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBRegDiscreteCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">UCHAR *&nbsp;</td>
          <td class="mdname" nowrap> <em>pucRegBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>USHORT&nbsp;</td>
          <td class="mdname" nowrap> <em>usAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>USHORT&nbsp;</td>
          <td class="mdname" nowrap> <em>usNDiscrete</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback function used if a <em>Input Discrete Register</em> value is read by the protocol stack. 
<p>
If you are going to use his function you might use the functions <a class="el" href="group__modbus__utils.html#ga0">xMBUtilSetBits(  )</a> and <a class="el" href="group__modbus__utils.html#ga1">xMBUtilGetBits(  )</a> for working with bitfields.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pucRegBuffer</em>&nbsp;</td><td>The buffer should be updated with the current coil values. The first discrete input starting at <code>usAddress</code> must be stored at the LSB of the first byte in the buffer. If the requested number is not a multiple of eight the remaining bits should be set to zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usAddress</em>&nbsp;</td><td>The starting address of the first discrete input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usNDiscrete</em>&nbsp;</td><td>Number of discrete input values. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The function must return one of the following error codes:<ul>
<li><a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a> If no error occurred. In this case a normal Modbus response is sent.</li><li><a class="el" href="group__modbus.html#gga11a7">eMBErrorCode::MB_ENOREG</a> If no such discrete inputs exists. In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.</li><li><a class="el" href="group__modbus.html#gga11a13">eMBErrorCode::MB_ETIMEDOUT</a> If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li><li><a class="el" href="group__modbus.html#gga11a11">eMBErrorCode::MB_EIO</a> If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li></ul>
</dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AT91SAM7X__ROWLEY_2demo_8c-example.html#a14">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a28">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a46">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a60">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a76">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a91">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a104">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a120">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a138">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a154">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="mb.h::eMBRegHoldingCB"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBRegHoldingCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">UCHAR *&nbsp;</td>
          <td class="mdname" nowrap> <em>pucRegBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>USHORT&nbsp;</td>
          <td class="mdname" nowrap> <em>usAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>USHORT&nbsp;</td>
          <td class="mdname" nowrap> <em>usNRegs</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__modbus.html#ga10">eMBRegisterMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>eMode</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback function used if a <em>Holding Register</em> value is read or written by the protocol stack. The starting register address is given by <code>usAddress</code> and the last register is given by <code>usAddress + usNRegs - 1</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pucRegBuffer</em>&nbsp;</td><td>If the application registers values should be updated the buffer points to the new registers values. If the protocol stack needs to now the current values the callback function should write them into this buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usAddress</em>&nbsp;</td><td>The starting address of the register. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usNRegs</em>&nbsp;</td><td>Number of registers to read or write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eMode</em>&nbsp;</td><td>If <a class="el" href="group__modbus.html#gga10a5">eMBRegisterMode::MB_REG_WRITE</a> the application register values should be updated from the values in the buffer. For example this would be the case when the Modbus master has issued an <b>WRITE SINGLE REGISTER</b> command. If the value <a class="el" href="group__modbus.html#gga10a4">eMBRegisterMode::MB_REG_READ</a> the application should copy the current values into the buffer <code>pucRegBuffer</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The function must return one of the following error codes:<ul>
<li><a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a> If no error occurred. In this case a normal Modbus response is sent.</li><li><a class="el" href="group__modbus.html#gga11a7">eMBErrorCode::MB_ENOREG</a> If the application can not supply values for registers within this range. In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.</li><li><a class="el" href="group__modbus.html#gga11a13">eMBErrorCode::MB_ETIMEDOUT</a> If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li><li><a class="el" href="group__modbus.html#gga11a11">eMBErrorCode::MB_EIO</a> If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li></ul>
</dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AT91SAM7X__ROWLEY_2demo_8c-example.html#a9">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a25">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a41">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a57">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a71">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a86">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a101">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a115">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a133">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a149">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="mb.h::eMBRegInputCB"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBRegInputCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">UCHAR *&nbsp;</td>
          <td class="mdname" nowrap> <em>pucRegBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>USHORT&nbsp;</td>
          <td class="mdname" nowrap> <em>usAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>USHORT&nbsp;</td>
          <td class="mdname" nowrap> <em>usNRegs</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback function used if the value of a <em>Input Register</em> is required by the protocol stack. The starting register address is given by <code>usAddress</code> and the last register is given by <code>usAddress + usNRegs - 1</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pucRegBuffer</em>&nbsp;</td><td>A buffer where the callback function should write the current value of the modbus registers to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usAddress</em>&nbsp;</td><td>The starting address of the register. Input registers are in the range 1 - 65535. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usNRegs</em>&nbsp;</td><td>Number of registers the callback function must supply.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The function must return one of the following error codes:<ul>
<li><a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a> If no error occurred. In this case a normal Modbus response is sent.</li><li><a class="el" href="group__modbus.html#gga11a7">eMBErrorCode::MB_ENOREG</a> If the application can not supply values for registers within this range. In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.</li><li><a class="el" href="group__modbus.html#gga11a13">eMBErrorCode::MB_ETIMEDOUT</a> If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li><li><a class="el" href="group__modbus.html#gga11a11">eMBErrorCode::MB_EIO</a> If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li></ul>
</dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AT91SAM7X__ROWLEY_2demo_8c-example.html#a6">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a22">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a39">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a54">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a69">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a84">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a98">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a113">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a131">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a147">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>

<hr width="80%">
<p><center>Automatically generated by Doxygen 1.4.2 on 13 Sep 2018.</center></p>

</body>
</html>
