<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>FreeModbus: Porting for RTU/ASCII</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>

<!-- Generated by Doxygen 1.4.2 -->
<h1><a class="anchor" name="sec_porting_serial">Porting for RTU/ASCII</a></h1>The first steps should always be to create a new directory for the port. The recommended layout is to create a top level directory, e.g. <code>demo/PLATFORM</code> which hold the application and project files. In addition a subdirectory <code>port</code> should be created for the port specific files. <div class="fragment"><pre class="fragment">demo/PLATFORM/Makefile
demo/PLATFORM/main.c
demo/PLATFORM/port/portserial.c
demo/PLATFORM/port/porttimer.c
demo/PLATFORM/port/portother.c
demo/PLATFORM/port/port.h
</pre></div> You can use <code>demo/BARE</code> as a starting point. Simply copy the directory and rename it to a name of your choice.<h2><a class="anchor" name="sec_porting_types">
Platform specifics (port.h)</a></h2>
You should first check the file <code><a class="el" href="port_8h.html">port.h</a></code> and check the if the examples are already suitable for your platform. You must at least define the macros for enabling <code>ENTER_CRITICAL_SECTION</code> and disabling <code>EXIT_CRITICAL_SECTION</code> interrupts.<h2><a class="anchor" name="sec_porting_timers">
Implementation of the timer functions (porttimer.c)</a></h2>
The Modbus protocol stacks needs a timer to detect the end of the frame. The timers should have a resolution of half the time of a serial character. For example for 38400 baud the character time is approx. 280us assuming 11bits for a single character. The smallest timeout used by the protocol stack is 3.5 times the character timeout. <p>
You should start by implementing the function <code>xMBPortTimersInit( USHORT usTim1Timerout50us )</code> and <code>vMBPortTimersEnable(  )</code>. Test the function with the following sample code: <div class="fragment"><pre class="fragment">xMBPortTimersInit( 20 );
vMBPortTimersEnable( );
<span class="keywordflow">for</span>( ;; );
</pre></div> Place a breakpoint or toggle an LED in the interrupt handler which calls <code>pxMBPortCBTimerExpired</code>. The ISR should occur approx. 1ms after the call to <code>vMBPortTimersEnable()</code>. You should also check that <code>vMBPortTimersDisable( )</code> works as expected.  <dl compact><dt><b>Note:</b></dt><dd>If you use Modbus ASCII the timers are in the range of seconds because the timeouts are much larger there. Make sure you can handle a value of 20000 for <code>usTim1Timerout50us</code> which corresponds to an one second timeout. See <code><a class="el" href="mbconfig_8h.html">mbconfig.h</a></code> for the value of the timeout defined by <code>MB_ASCII_TIMEOUT_SEC</code>.</dd></dl>
<h2><a class="anchor" name="sec_porting_serial">
Porting for RTU/ASCII</a></h2>
The serial porting layer must be capable of initializing the UART, disabling and enabling the receiver and transmitter components as well as performing callbacks if a character has been received or can be transmitted. You should start by implementing <code>xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity )</code> and <code>vMBPortSerialEnable(  BOOL xRxEnable, BOOL xTxEnable )</code>. In addition you need to create two interrupt service routines for you communication devices. It is usually simpler to start with the receive interrupt. <p>
Create an interrupt handler for the receive interrupt, set a breakpoint there and check if <code>xMBPortSerialGetByte( CHAR * pucByte )</code> correctly returns the character. This can be tested by the following code: <div class="fragment"><pre class="fragment"><span class="comment">/* Initialize COM device 0 with 38400 baud, 8 data bits and no parity. */</span>
<span class="keywordflow">if</span>( xMBPortSerialInit( 0, 38400, 8, <a class="code" href="group__modbus.html#gga12a7">MB_PAR_NONE</a> ) == FALSE )
{
  fprintf(stderr, <span class="stringliteral">"error: com init failed"</span>);
}
<span class="keywordflow">else</span>
{
  <span class="comment">/* Enable the receiver. */</span> 
  vMBPortSerialEnable( TRUE, FALSE );
  <span class="comment">/* Now block. Any character received should cause an interrupt now. */</span>
  <span class="keywordflow">for</span>( ;; );
}
</pre></div> And your serial character received ISR should look like: <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> prvvUARTTxReadyISR( <span class="keywordtype">void</span> )
{
    CHAR cByte;
    ( void )xMBPortSerialGetByte( &amp;cByte );
    <span class="comment">/* Now cByte should contain the character received. */</span>
}
</pre></div>  <p>
Next you should check that the transmitter part is actually working as expected. Open a terminal program and simply call <code>xMBPortSerialPutByte( 'a' )</code> in the transmit buffer empty ISR. If you use the sample code from below exactly 10 characters should be received. <div class="fragment"><pre class="fragment"><span class="comment">/* Initialize COM device 0 with 38400 baud, 8 data bits and no parity. */</span>
<span class="keywordflow">if</span>( xMBPortSerialInit( 0, 38400, 8, <a class="code" href="group__modbus.html#gga12a7">MB_PAR_NONE</a> ) == FALSE )
{
  fprintf(stderr, <span class="stringliteral">"error: com init failed"</span>);
}
<span class="keywordflow">else</span>
{
  <span class="comment">/* Enable the transmitter. */</span> 
  vMBPortSerialEnable( FALSE, TRUE );
  <span class="comment">/* Now block. Any character received should cause an interrupt now. */</span>
  <span class="keywordflow">for</span>( ;; );
}
</pre></div> And you serial transmit buffer empty ISR should look like: <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiCnt = 0;

<span class="keywordtype">void</span> prvvUARTTxReadyISR( <span class="keywordtype">void</span> )
{
    <span class="keywordflow">if</span>( uiCnt++ &lt; 10 )
    {
        ( void )xMBPortSerialPutByte( <span class="charliteral">'a'</span> );
    }
    <span class="keywordflow">else</span>
    {
        vMBPortSerialEnable( FALSE, FALSE );
    }
}
</pre></div>  <p>
If you are sure everything works correctly change the interrupt routines back to the examples shown in <code><a class="el" href="portserial_8c.html">portserial.c</a></code> <h2><a class="anchor" name="sec_porting_event">
Implementing the event queue (portevent.c)</a></h2>
If you are not using an operating system the port is already finished and the demo application should work as expected. If you in the luck of having an operating system usage of the FreeModbus protocol stack differs in the following way:<p>
<ul>
<li>Create another task at startup which calls <a class="el" href="group__modbus.html#ga5">eMBPoll( )</a> in a loop. This should look like: <div class="fragment"><pre class="fragment"><span class="keywordflow">for</span>( ;; )
{
    ( void )<a class="code" href="group__modbus.html#ga5">eMBPoll</a>(  );
}
</pre></div> See the STR71x port for an FreeRTOS example.</li></ul>
<p>
<ul>
<li>Change the function <code>xMBPortEventPost</code> to post an event to a queue. Note that this function will be called from an ISR so check your RTOS documentation for that.</li></ul>
<p>
<ul>
<li>Change the <code>xMBPortEventGet</code> to retrieve an event from that queue. The function <code>eMBPoll</code> periodically calls it. The function should block until an event has been posted to the queue.</li></ul>
<p>
In addition the serial and timer interrupt function must be modified. Whenever the protocol handler callback functions <code>pxMBFrameCBByteReceived</code>, <code>pxMBFrameCBTransmitterEmpty</code> and <code>pxMBPortCBTimerExpired</code> return <code>TRUE</code> a context switch should be made after exiting the ISR because an event has been posted to the queue. Forgetting to do this will result in slow performance of the protocol stack. 
<hr width="80%">
<p><center>Automatically generated by Doxygen 1.4.2 on 13 Sep 2018.</center></p>

</body>
</html>
