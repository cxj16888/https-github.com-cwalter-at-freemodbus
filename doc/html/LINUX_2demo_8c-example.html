<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>FreeModbus: LINUX/demo.c</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>

<!-- Generated by Doxygen 1.4.2 -->
<h1>LINUX/demo.c</h1><div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * FreeModbus Libary: Linux Demo Application</span>
<span class="comment"> * Copyright (C) 2006 Christian Walter &lt;wolti@sil.at&gt;</span>
<span class="comment"> *</span>
<span class="comment"> * This library is free software; you can redistribute it and/or</span>
<span class="comment"> * modify it under the terms of the GNU Lesser General Public</span>
<span class="comment"> * License as published by the Free Software Foundation; either</span>
<span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This library is distributed in the hope that it will be useful,</span>
<span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="comment"> * Lesser General Public License for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU Lesser General Public</span>
<span class="comment"> * License along with this library; if not, write to the Free Software</span>
<span class="comment"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="comment"> *</span>
<span class="comment"> * File: $Id$</span>
<span class="comment"> */</span>

<span class="comment">/* ----------------------- Standard includes --------------------------------*/</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>
<span class="preprocessor">#include &lt;errno.h&gt;</span>
<span class="preprocessor">#include &lt;pthread.h&gt;</span>
<span class="preprocessor">#include &lt;signal.h&gt;</span>

<span class="comment">/* ----------------------- Modbus includes ----------------------------------*/</span>
<span class="preprocessor">#include "mb.h"</span>
<span class="preprocessor">#include "mbport.h"</span>

<span class="comment">/* ----------------------- Defines ------------------------------------------*/</span>
<span class="preprocessor">#define PROG            "freemodbus"</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define REG_INPUT_START 1000</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_INPUT_NREGS 4</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_HOLDING_START 2000</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_HOLDING_NREGS 130</span>
<span class="preprocessor"></span>
<span class="comment">/* ----------------------- Static variables ---------------------------------*/</span>
<span class="keyword">static</span> USHORT   usRegInputStart = REG_INPUT_START;
<span class="keyword">static</span> USHORT   usRegInputBuf[REG_INPUT_NREGS];
<span class="keyword">static</span> USHORT   usRegHoldingStart = REG_HOLDING_START;
<span class="keyword">static</span> USHORT   usRegHoldingBuf[REG_HOLDING_NREGS];

<span class="keyword">static</span> <span class="keyword">enum</span> ThreadState
{
    STOPPED,
    RUNNING,
    SHUTDOWN
} ePollThreadState;

<span class="keyword">static</span> pthread_mutex_t xLock = PTHREAD_MUTEX_INITIALIZER;
<span class="keyword">static</span> BOOL     bDoExit;

<span class="comment">/* ----------------------- Static functions ---------------------------------*/</span>
<span class="keyword">static</span> BOOL     bCreatePollingThread( <span class="keywordtype">void</span> );
<span class="keyword">static</span> <span class="keyword">enum</span> ThreadState eGetPollingThreadState( <span class="keywordtype">void</span> );
<span class="keyword">static</span> <span class="keywordtype">void</span>     vSetPollingThreadState( <span class="keyword">enum</span> ThreadState eNewState );
<span class="keyword">static</span> <span class="keywordtype">void</span>    *pvPollingThread( <span class="keywordtype">void</span> *pvParameter );

<span class="comment">/* ----------------------- Start implementation -----------------------------*/</span>
BOOL
bSetSignal( <span class="keywordtype">int</span> iSignalNr, <span class="keywordtype">void</span> ( *pSigHandler ) ( <span class="keywordtype">int</span> ) )
{
    BOOL            bResult;
    <span class="keyword">struct </span>sigaction xNewSig, xOldSig;

    xNewSig.sa_handler = pSigHandler;
    sigemptyset( &amp;xNewSig.sa_mask );
    xNewSig.sa_flags = 0;
    <span class="keywordflow">if</span>( sigaction( iSignalNr, &amp;xNewSig, &amp;xOldSig ) != 0 )
    {
        bResult = FALSE;
    }
    <span class="keywordflow">else</span>
    {
        bResult = TRUE;
    }
    <span class="keywordflow">return</span> bResult;
}

<span class="keywordtype">void</span>
vSigShutdown( <span class="keywordtype">int</span> xSigNr )
{
    <span class="keywordflow">switch</span> ( xSigNr )
    {
    <span class="keywordflow">case</span> SIGQUIT:
    <span class="keywordflow">case</span> SIGINT:
    <span class="keywordflow">case</span> SIGTERM:
        vSetPollingThreadState( SHUTDOWN );
        bDoExit = TRUE;
    }
}

<span class="keywordtype">int</span>
main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] )
{
    <span class="keywordtype">int</span>             iExitCode;
    CHAR            cCh;

    <span class="keyword">const</span> UCHAR     ucSlaveID[] = { 0xAA, 0xBB, 0xCC };
    <span class="keywordflow">if</span>( !bSetSignal( SIGQUIT, vSigShutdown ) ||
        !bSetSignal( SIGINT, vSigShutdown ) || !bSetSignal( SIGTERM, vSigShutdown ) )
    {
        fprintf( stderr, <span class="stringliteral">"%s: can't install signal handlers: %s!\n"</span>, PROG, strerror( errno ) );
        iExitCode = EXIT_FAILURE;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a name="a29"></a><a class="code" href="group__modbus.html#ga0">eMBInit</a>( <a name="a30"></a><a class="code" href="group__modbus.html#gga9a1">MB_RTU</a>, 0x0A, 0, 38400, <a name="a31"></a><a class="code" href="group__modbus.html#gga12a9">MB_PAR_EVEN</a> ) != <a name="a32"></a><a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> )
    {
        fprintf( stderr, <span class="stringliteral">"%s: can't initialize modbus stack!\n"</span>, PROG );
        iExitCode = EXIT_FAILURE;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a name="a33"></a><a class="code" href="group__modbus.html#ga6">eMBSetSlaveID</a>( 0x34, TRUE, ucSlaveID, 3 ) != <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> )
    {
        fprintf( stderr, <span class="stringliteral">"%s: can't set slave id!\n"</span>, PROG );
        iExitCode = EXIT_FAILURE;
    }
    <span class="keywordflow">else</span>
    {
        vSetPollingThreadState( STOPPED );

        <span class="comment">/* CLI interface. */</span>
        printf( <span class="stringliteral">"Type 'q' for quit or 'h' for help!\n"</span> );
        bDoExit = FALSE;
        <span class="keywordflow">do</span>
        {
            printf( <span class="stringliteral">"&gt; "</span> );
            cCh = getchar(  );

            <span class="keywordflow">switch</span> ( cCh )
            {
            <span class="keywordflow">case</span> <span class="charliteral">'q'</span>:
                bDoExit = TRUE;
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
                vSetPollingThreadState( SHUTDOWN );
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
                <span class="keywordflow">if</span>( bCreatePollingThread(  ) != TRUE )
                {
                    printf( <span class="stringliteral">"Can't start protocol stack! Already running?\n"</span> );
                }
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
                <span class="keywordflow">switch</span> ( eGetPollingThreadState(  ) )
                {
                <span class="keywordflow">case</span> RUNNING:
                    printf( <span class="stringliteral">"Protocol stack is running.\n"</span> );
                    <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> STOPPED:
                    printf( <span class="stringliteral">"Protocol stack is stopped.\n"</span> );
                    <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> SHUTDOWN:
                    printf( <span class="stringliteral">"Protocol stack is shuting down.\n"</span> );
                    <span class="keywordflow">break</span>;
                }
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
                printf( <span class="stringliteral">"FreeModbus demo application help:\n"</span> );
                printf( <span class="stringliteral">"  'd' ... disable protocol stack.\n"</span> );
                printf( <span class="stringliteral">"  'e' ... enabled the protocol stack.\n"</span> );
                printf( <span class="stringliteral">"  's' ... show current status.\n"</span> );
                printf( <span class="stringliteral">"  'q' ... quit application.\n"</span> );
                printf( <span class="stringliteral">"  'h' ... this information.\n"</span> );
                printf( <span class="stringliteral">"\n"</span> );
                printf( <span class="stringliteral">"Copyright 2006 Christian Walter &lt;wolti@sil.at&gt;\n"</span> );
                <span class="keywordflow">break</span>;
            <span class="keywordflow">default</span>:
                <span class="keywordflow">if</span>( !bDoExit &amp;&amp; ( cCh != <span class="charliteral">'\n'</span> ) )
                {
                    printf( <span class="stringliteral">"illegal command '%c'!\n"</span>, cCh );
                }
                <span class="keywordflow">break</span>;
            }

            <span class="comment">/* eat up everything untill return character. */</span>
            <span class="keywordflow">while</span>( !bDoExit &amp;&amp; ( cCh != <span class="charliteral">'\n'</span> ) )
            {
                cCh = getchar(  );
            }
        }
        <span class="keywordflow">while</span>( !bDoExit );

        <span class="comment">/* Release hardware resources. */</span>
        ( void )<a name="a34"></a><a class="code" href="group__modbus.html#ga2">eMBClose</a>(  );
        iExitCode = EXIT_SUCCESS;
    }
    <span class="keywordflow">return</span> iExitCode;
}

BOOL
bCreatePollingThread( <span class="keywordtype">void</span> )
{
    BOOL            bResult;
    pthread_t       xThread;

    <span class="keywordflow">if</span>( eGetPollingThreadState(  ) == STOPPED )
    {
        <span class="keywordflow">if</span>( pthread_create( &amp;xThread, NULL, pvPollingThread, NULL ) != 0 )
        {
            bResult = FALSE;
        }
        <span class="keywordflow">else</span>
        {
            bResult = TRUE;
        }
    }
    <span class="keywordflow">else</span>
    {
        bResult = FALSE;
    }

    <span class="keywordflow">return</span> bResult;
}

<span class="keywordtype">void</span>           *
pvPollingThread( <span class="keywordtype">void</span> *pvParameter )
{
    vSetPollingThreadState( RUNNING );

    <span class="keywordflow">if</span>( <a name="a35"></a><a class="code" href="group__modbus.html#ga3">eMBEnable</a>(  ) == <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> )
    {
        <span class="keywordflow">do</span>
        {
            <span class="keywordflow">if</span>( <a name="a36"></a><a class="code" href="group__modbus.html#ga5">eMBPoll</a>(  ) != <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> )
                <span class="keywordflow">break</span>;
            usRegInputBuf[0] = ( USHORT ) rand(  );
        }
        <span class="keywordflow">while</span>( eGetPollingThreadState(  ) != SHUTDOWN );
    }

    ( void )<a name="a37"></a><a class="code" href="group__modbus.html#ga4">eMBDisable</a>(  );

    vSetPollingThreadState( STOPPED );

    <span class="keywordflow">return</span> 0;
}

<span class="keyword">enum</span> ThreadState
eGetPollingThreadState(  )
{
    <span class="keyword">enum</span> ThreadState eCurState;

    ( void )pthread_mutex_lock( &amp;xLock );
    eCurState = ePollThreadState;
    ( void )pthread_mutex_unlock( &amp;xLock );

    <span class="keywordflow">return</span> eCurState;
}

<span class="keywordtype">void</span>
vSetPollingThreadState( <span class="keyword">enum</span> ThreadState eNewState )
{
    ( void )pthread_mutex_lock( &amp;xLock );
    ePollThreadState = eNewState;
    ( void )pthread_mutex_unlock( &amp;xLock );
}

<a name="a38"></a><a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a39"></a><a class="code" href="group__modbus__registers.html#ga0">eMBRegInputCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
    <a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    eStatus = <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a>;
    <span class="keywordtype">int</span>             iRegIndex;

    <span class="keywordflow">if</span>( ( usAddress &gt;= REG_INPUT_START )
        &amp;&amp; ( usAddress + usNRegs &lt;= REG_INPUT_START + REG_INPUT_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegInputStart );
        <span class="keywordflow">while</span>( usNRegs &gt; 0 )
        {
            *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegInputBuf[iRegIndex] &gt;&gt; 8 );
            *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegInputBuf[iRegIndex] &amp; 0xFF );
            iRegIndex++;
            usNRegs--;
        }
    }
    <span class="keywordflow">else</span>
    {
        eStatus = <a name="a40"></a><a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
    }

    <span class="keywordflow">return</span> eStatus;
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a41"></a><a class="code" href="group__modbus__registers.html#ga1">eMBRegHoldingCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, <a name="a42"></a><a class="code" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode )
{
    <a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    eStatus = <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a>;
    <span class="keywordtype">int</span>             iRegIndex;

    <span class="keywordflow">if</span>( ( usAddress &gt;= REG_HOLDING_START ) &amp;&amp;
        ( usAddress + usNRegs &lt;= REG_HOLDING_START + REG_HOLDING_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegHoldingStart );
        <span class="keywordflow">switch</span> ( eMode )
        {
            <span class="comment">/* Pass current register values to the protocol stack. */</span>
        <span class="keywordflow">case</span> <a name="a43"></a><a class="code" href="group__modbus.html#gga10a4">MB_REG_READ</a>:
            <span class="keywordflow">while</span>( usNRegs &gt; 0 )
            {
                *pucRegBuffer++ = ( UCHAR ) ( usRegHoldingBuf[iRegIndex] &gt;&gt; 8 );
                *pucRegBuffer++ = ( UCHAR ) ( usRegHoldingBuf[iRegIndex] &amp; 0xFF );
                iRegIndex++;
                usNRegs--;
            }
            <span class="keywordflow">break</span>;

            <span class="comment">/* Update current register values with new values from the</span>
<span class="comment">             * protocol stack. */</span>
        <span class="keywordflow">case</span> <a name="a44"></a><a class="code" href="group__modbus.html#gga10a5">MB_REG_WRITE</a>:
            <span class="keywordflow">while</span>( usNRegs &gt; 0 )
            {
                usRegHoldingBuf[iRegIndex] = *pucRegBuffer++ &lt;&lt; 8;
                usRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
                iRegIndex++;
                usNRegs--;
            }
        }
    }
    <span class="keywordflow">else</span>
    {
        eStatus = <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
    }
    <span class="keywordflow">return</span> eStatus;
}


<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a45"></a><a class="code" href="group__modbus__registers.html#ga2">eMBRegCoilsCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, <a class="code" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode )
{
    <span class="keywordflow">return</span> <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a46"></a><a class="code" href="group__modbus__registers.html#ga3">eMBRegDiscreteCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
    <span class="keywordflow">return</span> <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
}
</pre></div> 
<hr width="80%">
<p><center>Automatically generated by Doxygen 1.4.2 on 13 Sep 2018.</center></p>

</body>
</html>
