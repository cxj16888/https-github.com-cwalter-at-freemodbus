<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>FreeModbus: MCF5235TCP/demo.c</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>

<!-- Generated by Doxygen 1.4.2 -->
<h1>MCF5235TCP/demo.c</h1><div class="fragment"><pre class="fragment"><span class="comment">/* ------------------------ System includes ------------------------------- */</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;assert.h&gt;</span>

<span class="comment">/* ------------------------ FreeRTOS includes ----------------------------- */</span>
<span class="preprocessor">#include "FreeRTOS.h"</span>
<span class="preprocessor">#include "task.h"</span>

<span class="comment">/* ------------------------ LWIP includes --------------------------------- */</span>
<span class="preprocessor">#include "lwip/api.h"</span>
<span class="preprocessor">#include "lwip/tcpip.h"</span>
<span class="preprocessor">#include "lwip/memp.h"</span>

<span class="comment">/* ------------------------ FreeModbus includes --------------------------- */</span>
<span class="preprocessor">#include "mb.h"</span>

<span class="comment">/* ------------------------ Project includes ------------------------------ */</span>
<span class="preprocessor">#include "mcf5xxx.h"</span>
<span class="preprocessor">#include "mcf523x.h"</span>
<span class="preprocessor">#include "netif/fec.h"</span>

<span class="preprocessor">#include "serial.h"</span>

<span class="comment">/* ------------------------ Defines --------------------------------------- */</span>
<span class="preprocessor">#define mainCOM_TEST_BAUD_RATE  ( ( unsigned portLONG ) 38400 )</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define mainMB_TASK_PRIORITY    ( tskIDLE_PRIORITY + 3 )</span>
<span class="preprocessor"></span><span class="preprocessor">#define PROG                    "FreeModbus"</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_INPUT_START         1000</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_INPUT_NREGS         4</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_HOLDING_START       2000</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_HOLDING_NREGS       130</span>
<span class="preprocessor"></span>
<span class="comment">/* ----------------------- Static variables ---------------------------------*/</span>
<span class="keyword">static</span> USHORT   usRegInputStart = REG_INPUT_START;
<span class="keyword">static</span> USHORT   usRegInputBuf[REG_INPUT_NREGS];
<span class="keyword">static</span> USHORT   usRegHoldingStart = REG_HOLDING_START;
<span class="keyword">static</span> USHORT   usRegHoldingBuf[REG_HOLDING_NREGS];

xComPortHandle  xSTDComPort = NULL;

<span class="comment">/* ------------------------ Static functions ------------------------------ */</span>
<span class="keyword">static</span> <span class="keywordtype">void</span>     vlwIPInit( <span class="keywordtype">void</span> );
<span class="keyword">static</span> <span class="keywordtype">void</span>     vMBServerTask( <span class="keywordtype">void</span> *arg );

<span class="comment">/* ------------------------ Implementation -------------------------------- */</span>
<span class="keywordtype">int</span>
main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] )
{
    <span class="keyword">asm</span> <span class="keyword">volatile</span>    ( <span class="stringliteral">"move.w  #0x2000, %sr\n\t"</span> );

    <span class="comment">/* Initialize serial communication device. */</span>
    xSTDComPort = xSerialPortInitMinimal( 38400, 8 );

    <span class="comment">/* Initialize lwIP protocol stack. */</span>
    vlwIPInit(  );

    <span class="keywordflow">if</span>( sys_thread_new( vMBServerTask, NULL, mainMB_TASK_PRIORITY ) == NULL )
    {
        fprintf( stderr, <span class="stringliteral">"%s: can't create modbus task!\r\n"</span>, PROG );
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">/* Now all the tasks have been started - start the scheduler. */</span>
        vTaskStartScheduler(  );
    }

    <span class="comment">/* Should never get here! */</span>
    <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">void</span>
vlwIPInit( <span class="keywordtype">void</span> )
{
    <span class="comment">/* Initialize lwIP and its interface layer. */</span>
    sys_init(  );
    mem_init(  );
    memp_init(  );
    pbuf_init(  );
    netif_init(  );
    ip_init(  );
    tcpip_init( NULL, NULL );
}

<span class="keywordtype">void</span>
vMBServerTask( <span class="keywordtype">void</span> *arg )
{
    <a name="a61"></a><a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    xStatus;
    <span class="keyword">struct </span>ip_addr  xIpAddr, xNetMast, xGateway;
    <span class="keyword">struct </span>netif    xFEC523x;

    IP4_ADDR( &amp;xIpAddr, 10, 0, 10, 2 );
    IP4_ADDR( &amp;xNetMast, 255, 255, 255, 0 );
    IP4_ADDR( &amp;xGateway, 10, 0, 10, 1 );
    netif_add( &amp;xFEC523x, &amp;xIpAddr, &amp;xNetMast, &amp;xGateway, NULL, mcf523xfec_init, tcpip_input );
    <span class="comment">/* Make it the default interface */</span>
    netif_set_default( &amp;xFEC523x );
    <span class="comment">/* Bring it up */</span>
    netif_set_up( &amp;xFEC523x );


    <span class="keywordflow">for</span>( ;; )
    {
        <span class="keywordflow">if</span>( <a name="a62"></a><a class="code" href="group__modbus.html#ga1">eMBTCPInit</a>( <a name="a63"></a><a class="code" href="group__modbus.html#ga8">MB_TCP_PORT_USE_DEFAULT</a> ) != <a name="a64"></a><a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> )
        {
            fprintf( stderr, <span class="stringliteral">"%s: can't initialize modbus stack!\r\n"</span>, PROG );
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a name="a65"></a><a class="code" href="group__modbus.html#ga3">eMBEnable</a>(  ) != <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> )
        {
            fprintf( stderr, <span class="stringliteral">"%s: can't enable modbus stack!\r\n"</span>, PROG );
        }
        <span class="keywordflow">else</span>
        {
            <span class="keywordflow">do</span>
            {
                xStatus = <a name="a66"></a><a class="code" href="group__modbus.html#ga5">eMBPoll</a>(  );
            }
            <span class="keywordflow">while</span>( xStatus == <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> );
        }
        <span class="comment">/* An error occured. Maybe we can restart. */</span>
        ( void )<a name="a67"></a><a class="code" href="group__modbus.html#ga4">eMBDisable</a>(  );
        ( void )<a name="a68"></a><a class="code" href="group__modbus.html#ga2">eMBClose</a>(  );
    }
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a69"></a><a class="code" href="group__modbus__registers.html#ga0">eMBRegInputCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
    <a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    eStatus = <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a>;
    <span class="keywordtype">int</span>             iRegIndex;

    <span class="keywordflow">if</span>( ( usAddress &gt;= REG_INPUT_START )
        &amp;&amp; ( usAddress + usNRegs &lt;= REG_INPUT_START + REG_INPUT_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegInputStart );
        <span class="keywordflow">while</span>( usNRegs &gt; 0 )
        {
            *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegInputBuf[iRegIndex] &gt;&gt; 8 );
            *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegInputBuf[iRegIndex] &amp; 0xFF );
            iRegIndex++;
            usNRegs--;
        }
    }
    <span class="keywordflow">else</span>
    {
        eStatus = <a name="a70"></a><a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
    }
    <span class="keywordflow">return</span> eStatus;
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a71"></a><a class="code" href="group__modbus__registers.html#ga1">eMBRegHoldingCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, <a name="a72"></a><a class="code" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode )
{
    <a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    eStatus = <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a>;
    <span class="keywordtype">int</span>             iRegIndex;

    <span class="keywordflow">if</span>( ( usAddress &gt;= REG_HOLDING_START ) &amp;&amp;
        ( usAddress + usNRegs &lt;= REG_HOLDING_START + REG_HOLDING_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegHoldingStart );
        <span class="keywordflow">switch</span> ( eMode )
        {
            <span class="comment">/* Pass current register values to the protocol stack. */</span>
        <span class="keywordflow">case</span> <a name="a73"></a><a class="code" href="group__modbus.html#gga10a4">MB_REG_READ</a>:
            <span class="keywordflow">while</span>( usNRegs &gt; 0 )
            {
                *pucRegBuffer++ = ( UCHAR ) ( usRegHoldingBuf[iRegIndex] &gt;&gt; 8 );
                *pucRegBuffer++ = ( UCHAR ) ( usRegHoldingBuf[iRegIndex] &amp; 0xFF );
                iRegIndex++;
                usNRegs--;
            }
            <span class="keywordflow">break</span>;

            <span class="comment">/* Update current register values with new values from the</span>
<span class="comment">             * protocol stack. */</span>
        <span class="keywordflow">case</span> <a name="a74"></a><a class="code" href="group__modbus.html#gga10a5">MB_REG_WRITE</a>:
            <span class="keywordflow">while</span>( usNRegs &gt; 0 )
            {
                usRegHoldingBuf[iRegIndex] = *pucRegBuffer++ &lt;&lt; 8;
                usRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
                iRegIndex++;
                usNRegs--;
            }
        }
    }
    <span class="keywordflow">else</span>
    {
        eStatus = <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
    }
    <span class="keywordflow">return</span> eStatus;
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a75"></a><a class="code" href="group__modbus__registers.html#ga2">eMBRegCoilsCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, <a class="code" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode )
{
    <span class="keywordflow">return</span> <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a76"></a><a class="code" href="group__modbus__registers.html#ga3">eMBRegDiscreteCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
    <span class="keywordflow">return</span> <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
}
</pre></div> 
<hr width="80%">
<p><center>Automatically generated by Doxygen 1.4.2 on 13 Sep 2018.</center></p>

</body>
</html>
