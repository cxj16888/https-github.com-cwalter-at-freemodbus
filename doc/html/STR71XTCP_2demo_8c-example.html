<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>FreeModbus: STR71XTCP/demo.c</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>

<!-- Generated by Doxygen 1.4.2 -->
<h1>STR71XTCP/demo.c</h1><div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * FreeModbus Libary: STR71XTCP Demo Application</span>
<span class="comment"> * Copyright (C) 2006 Christian Walter &lt;wolti@sil.at&gt;</span>
<span class="comment"> *</span>
<span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="comment"> * (at your option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment"> * GNU General Public License for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU General Public License</span>
<span class="comment"> * along with this program; if not, write to the Free Software</span>
<span class="comment"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="comment"> *</span>
<span class="comment"> * File: $Id$</span>
<span class="comment"> */</span>

<span class="comment">/* ----------------------- System includes ----------------------------------*/</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="comment">/* ----------------------- lwIP includes ------------------------------------*/</span>
<span class="preprocessor">#include "lwip/opt.h"</span>
<span class="preprocessor">#include "lwip/sio.h"</span>
<span class="preprocessor">#include "lwip/sys.h"</span>
<span class="preprocessor">#include "lwip/inet.h"</span>
<span class="preprocessor">#include "ppp/ppp.h"</span>
<span class="preprocessor">#include "arch/cc.h"</span>

<span class="comment">/* ----------------------- FreeRTOS includes --------------------------------*/</span>
<span class="preprocessor">#include "FreeRTOS.h"</span>
<span class="preprocessor">#include "task.h"</span>
<span class="preprocessor">#include "queue.h"</span>

<span class="comment">/* ----------------------- Platform includes --------------------------------*/</span>
<span class="preprocessor">#include "eic.h"</span>
<span class="preprocessor">#include "netif/serial.h"</span>

<span class="comment">/* ----------------------- Modbus includes ----------------------------------*/</span>
<span class="preprocessor">#include "mb.h"</span>

<span class="comment">/* ----------------------- Defines ------------------------------------------*/</span>
<span class="preprocessor">#define mainMB_TASK_PRIORITY    ( tskIDLE_PRIORITY + 3 )</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_INPUT_START         1000</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_INPUT_NREGS         4</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_HOLDING_START       2000</span>
<span class="preprocessor"></span><span class="preprocessor">#define REG_HOLDING_NREGS       130</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define PPP_AUTH_ENABLED        1</span>
<span class="preprocessor"></span><span class="preprocessor">#define PPP_USER                "freemodbus"</span>
<span class="preprocessor"></span><span class="preprocessor">#define PPP_PASS                "insecure"</span>
<span class="preprocessor"></span>
<span class="comment">/* ----------------------- Type definitions ---------------------------------*/</span>
<span class="keyword">typedef</span> <span class="keyword">enum</span>
{
    CONNECTING, CONNECTED, DISCONNECT
} ePPPThreadControl;

<span class="comment">/* ----------------------- Static variables ---------------------------------*/</span>
<span class="keyword">static</span> USHORT   usRegInputStart = REG_INPUT_START;
<span class="keyword">static</span> USHORT   usRegInputBuf[REG_INPUT_NREGS];
<span class="keyword">static</span> USHORT   usRegHoldingStart = REG_HOLDING_START;
<span class="keyword">static</span> USHORT   usRegHoldingBuf[REG_HOLDING_NREGS];
<span class="keyword">static</span> ePPPThreadControl ePPPThrCtl;


<span class="comment">/* ----------------------- Static functions ---------------------------------*/</span>
<span class="keyword">static</span> <span class="keywordtype">void</span>     vlwIPInit( <span class="keywordtype">void</span> );
<span class="keyword">static</span> <span class="keywordtype">void</span>     vMBServerTask( <span class="keywordtype">void</span> *arg );
<span class="keyword">static</span> <span class="keywordtype">void</span>     vPPPStatusCB( <span class="keywordtype">void</span> *ctx, <span class="keywordtype">int</span> errCode, <span class="keywordtype">void</span> *arg );

sio_fd_t        stdio_fd;
sio_fd_t        ppp_fd;

<span class="comment">/* ----------------------- Start implementation -----------------------------*/</span>
<span class="keywordtype">int</span>
main( <span class="keywordtype">void</span> )
{
    EIC_Init(  );
    EIC_IRQConfig( ENABLE );

    <span class="comment">/* Use UART0 as stdin/stdout for debug purposes. */</span>
    <span class="keywordflow">if</span>( ( stdio_fd = sio_open_new( 0, 115200, 8, SIO_STOP_1, SIO_PAR_NONE ) ) == SIO_FD_NULL )
    {
        <span class="comment">/* nothing we can do here - no stdout means no logging. */</span>
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">/* Initialize lwIP and its interface layer. */</span>
        vlwIPInit(  );

        <span class="comment">/* Use UART1 as PPP device. */</span>
        <span class="keywordflow">if</span>( ( ppp_fd = sio_open_new( 1, 115200, 8, SIO_STOP_1, SIO_PAR_NONE ) ) == SIO_FD_NULL )
        {
            vMBPortLog( MB_LOG_ERROR, <span class="stringliteral">"PPP"</span>, <span class="stringliteral">"can't open PPP device!\r\n"</span> );
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>( sys_thread_new( vMBServerTask, NULL, mainMB_TASK_PRIORITY ) == SYS_THREAD_NULL )
        {
            vMBPortLog( MB_LOG_ERROR, <span class="stringliteral">"MB-INIT"</span>, <span class="stringliteral">"can't start modbus task!\r\n"</span> );
        }
        <span class="keywordflow">else</span>
        {
            vMBPortLog( MB_LOG_INFO, <span class="stringliteral">"MB-INIT"</span>, <span class="stringliteral">"FreeModbus demo application starting...\r\n"</span> );
            <span class="comment">/* Everything ready. Start the scheduler. */</span>
            vTaskStartScheduler(  );
        }
    }

    <span class="keywordflow">for</span>( ;; );
}

<span class="keywordtype">void</span>
vlwIPInit( <span class="keywordtype">void</span> )
{
    sys_init(  );
    mem_init(  );
    memp_init(  );
    pbuf_init(  );
    netif_init(  );
    ip_init(  );
    tcpip_init( NULL, NULL );
}

<span class="keywordtype">void</span>
vMBServerTask( <span class="keywordtype">void</span> *arg )
{
    <a name="a105"></a><a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    xStatus;
    ePPPThreadControl ePPPThrCtlCur;
    <span class="keywordtype">int</span>             ppp_con_fd;
    portTickType    xTicks;

    pppInit(  );
    <span class="keywordflow">if</span>( PPP_AUTH_ENABLED )
    {
      pppSetAuth( PPPAUTHTYPE_PAP, PPP_USER, PPP_PASS );
    }
    <span class="keywordflow">else</span>
    {
      pppSetAuth( PPPAUTHTYPE_NONE, NULL, NULL );
    }
    <span class="keywordflow">do</span>
    {
        vPortEnterCritical(  );
        ePPPThrCtl = CONNECTING;
        vPortExitCritical(  );
        <span class="keywordflow">if</span>( ( ppp_con_fd = pppOpen( ppp_fd, vPPPStatusCB, NULL ) ) == PPPERR_NONE )
        {
            <span class="comment">/* Check every 50ms if the state of the connecton has changed.</span>
<span class="comment">             * This could either mean it was aborted or successful.</span>
<span class="comment">             */</span>
            <span class="keywordflow">do</span>
            {
                vTaskDelay( ( portTickType ) ( 50UL / portTICK_RATE_MS ) );
                vPortEnterCritical(  );
                ePPPThrCtlCur = ePPPThrCtl;
                vPortExitCritical(  );
            }
            <span class="keywordflow">while</span>( ePPPThrCtlCur == CONNECTING );

            <span class="keywordflow">if</span>( ePPPThrCtlCur == CONNECTED )
            {
                <span class="keywordflow">if</span>( <a name="a106"></a><a class="code" href="group__modbus.html#ga1">eMBTCPInit</a>( <a name="a107"></a><a class="code" href="group__modbus.html#ga8">MB_TCP_PORT_USE_DEFAULT</a> ) != <a name="a108"></a><a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> )
                {
                    vMBPortLog( MB_LOG_ERROR, <span class="stringliteral">"PPP"</span>, <span class="stringliteral">"can't initalize modbus stack!\r\n"</span> );
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a name="a109"></a><a class="code" href="group__modbus.html#ga3">eMBEnable</a>(  ) != <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> )
                {
                    vMBPortLog( MB_LOG_ERROR, <span class="stringliteral">"PPP"</span>, <span class="stringliteral">"can't enable modbus stack!\r\n"</span> );
                }
                <span class="keywordflow">else</span>
                {
                    <span class="keywordflow">do</span>
                    {
                        vPortEnterCritical(  );
                        ePPPThrCtlCur = ePPPThrCtl;
                        vPortExitCritical(  );

                        <span class="comment">/* Application code here. */</span>
                        xStatus = <a name="a110"></a><a class="code" href="group__modbus.html#ga5">eMBPoll</a>(  );

                        <span class="comment">/* Update input registers with the current system  tick. */</span>
                        xTicks = xTaskGetTickCount(  );

                        <span class="comment">/* Note: little endian stuff */</span>
                        usRegInputBuf[0] = ( USHORT ) ( xTicks );
                        usRegInputBuf[1] = ( USHORT ) ( xTicks &gt;&gt; 16UL );

                    }
                    <span class="keywordflow">while</span>( ( xStatus == <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a> ) &amp;&amp; ( ePPPThrCtlCur == CONNECTED ) );

                    ( void )<a name="a111"></a><a class="code" href="group__modbus.html#ga4">eMBDisable</a>(  );
                    ( void )<a name="a112"></a><a class="code" href="group__modbus.html#ga2">eMBClose</a>(  );
                }
            }
            <span class="comment">/* FIXME: pppClose bugs because thread is not stopped. */</span>
            <span class="comment">/* Connection has been closed. */</span>
            pppClose( ppp_con_fd );
        }

        <span class="comment">/* Wait 1s until reopening the connection. */</span>
        vTaskDelay( ( portTickType ) ( 1000UL / portTICK_RATE_MS ) );
    }
    <span class="keywordflow">while</span>( pdTRUE );
}

<span class="keywordtype">void</span>
vPPPStatusCB( <span class="keywordtype">void</span> *ctx, <span class="keywordtype">int</span> err, <span class="keywordtype">void</span> *arg )
{
    <span class="comment">/* Imported from ipcp.c */</span>
    <span class="keyword">extern</span> <span class="keywordtype">char</span>    *_inet_ntoa( u32_t n );

    ePPPThreadControl ePPPThrCtlNew;
    <span class="keyword">struct </span>ppp_addrs *ppp_addrs;

    <span class="keywordflow">switch</span> ( err )
    {
        <span class="comment">/* No error. */</span>
    <span class="keywordflow">case</span> PPPERR_NONE:
        ePPPThrCtlNew = CONNECTED;
        ppp_addrs = arg;
        vMBPortLog( MB_LOG_INFO, <span class="stringliteral">"PPP"</span>, <span class="stringliteral">"new PPP connection established\r\n"</span> );
        vMBPortLog( MB_LOG_INFO, <span class="stringliteral">"PPP"</span>, <span class="stringliteral">"  our IP address = %s\r\n"</span>,
                    _inet_ntoa( ppp_addrs-&gt;our_ipaddr.addr ) );
        vMBPortLog( MB_LOG_INFO, <span class="stringliteral">"PPP"</span>, <span class="stringliteral">"  his IP address = %s\r\n"</span>,
                    _inet_ntoa( ppp_addrs-&gt;his_ipaddr.addr ) );
        vMBPortLog( MB_LOG_INFO, <span class="stringliteral">"PPP"</span>, <span class="stringliteral">"  netmask = %s\r\n"</span>,
                    _inet_ntoa( ppp_addrs-&gt;netmask.addr ) );
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        ePPPThrCtlNew = DISCONNECT;
        vMBPortLog( MB_LOG_ERROR, <span class="stringliteral">"PPP"</span>, <span class="stringliteral">"PPP connection died ( err = %d )\r\n"</span>, err );
        <span class="keywordflow">break</span>;
    }
    vPortEnterCritical(  );
    ePPPThrCtl = ePPPThrCtlNew;
    vPortExitCritical(  );
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a113"></a><a class="code" href="group__modbus__registers.html#ga0">eMBRegInputCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
    <a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    eStatus = <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a>;
    <span class="keywordtype">int</span>             iRegIndex;

    <span class="keywordflow">if</span>( ( usAddress &gt;= REG_INPUT_START )
        &amp;&amp; ( usAddress + usNRegs &lt;= REG_INPUT_START + REG_INPUT_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegInputStart );
        <span class="keywordflow">while</span>( usNRegs &gt; 0 )
        {
            *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegInputBuf[iRegIndex] &gt;&gt; 8 );
            *pucRegBuffer++ = ( <span class="keywordtype">unsigned</span> char )( usRegInputBuf[iRegIndex] &amp; 0xFF );
            iRegIndex++;
            usNRegs--;
        }
    }
    <span class="keywordflow">else</span>
    {
        eStatus = <a name="a114"></a><a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
    }
    <span class="keywordflow">return</span> eStatus;
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a115"></a><a class="code" href="group__modbus__registers.html#ga1">eMBRegHoldingCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, <a name="a116"></a><a class="code" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode )
{
    <a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>    eStatus = <a class="code" href="group__modbus.html#gga11a6">MB_ENOERR</a>;
    <span class="keywordtype">int</span>             iRegIndex;

    <span class="keywordflow">if</span>( ( usAddress &gt;= REG_HOLDING_START ) &amp;&amp;
        ( usAddress + usNRegs &lt;= REG_HOLDING_START + REG_HOLDING_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegHoldingStart );
        <span class="keywordflow">switch</span> ( eMode )
        {
            <span class="comment">/* Pass current register values to the protocol stack. */</span>
        <span class="keywordflow">case</span> <a name="a117"></a><a class="code" href="group__modbus.html#gga10a4">MB_REG_READ</a>:
            <span class="keywordflow">while</span>( usNRegs &gt; 0 )
            {
                *pucRegBuffer++ = ( UCHAR ) ( usRegHoldingBuf[iRegIndex] &gt;&gt; 8 );
                *pucRegBuffer++ = ( UCHAR ) ( usRegHoldingBuf[iRegIndex] &amp; 0xFF );
                iRegIndex++;
                usNRegs--;
            }
            <span class="keywordflow">break</span>;

            <span class="comment">/* Update current register values with new values from the</span>
<span class="comment">             * protocol stack. */</span>
        <span class="keywordflow">case</span> <a name="a118"></a><a class="code" href="group__modbus.html#gga10a5">MB_REG_WRITE</a>:
            <span class="keywordflow">while</span>( usNRegs &gt; 0 )
            {
                usRegHoldingBuf[iRegIndex] = *pucRegBuffer++ &lt;&lt; 8;
                usRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
                iRegIndex++;
                usNRegs--;
            }
        }
    }
    <span class="keywordflow">else</span>
    {
        eStatus = <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
    }
    <span class="keywordflow">return</span> eStatus;
}


<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a119"></a><a class="code" href="group__modbus__registers.html#ga2">eMBRegCoilsCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, <a class="code" href="group__modbus.html#ga10">eMBRegisterMode</a> eMode )
{
    <span class="keywordflow">return</span> <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
}

<a class="code" href="group__modbus.html#ga11">eMBErrorCode</a>
<a name="a120"></a><a class="code" href="group__modbus__registers.html#ga3">eMBRegDiscreteCB</a>( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
    <span class="keywordflow">return</span> <a class="code" href="group__modbus.html#gga11a7">MB_ENOREG</a>;
}
</pre></div> 
<hr width="80%">
<p><center>Automatically generated by Doxygen 1.4.2 on 13 Sep 2018.</center></p>

</body>
</html>
