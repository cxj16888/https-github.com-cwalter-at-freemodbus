<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>FreeModbus: Modbus</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>

<!-- Generated by Doxygen 1.4.2 -->
<h1>Modbus</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "mb.h"</span> 
</pre></div><p>
This module defines the interface for the application. It contains the basic functions and types required to use the Modbus protocol stack. A typical application will want to call <a class="el" href="group__modbus.html#ga0">eMBInit()</a> first. If the device is ready to answer network requests it must then call <a class="el" href="group__modbus.html#ga3">eMBEnable()</a> to activate the protocol stack. In the main loop the function <a class="el" href="group__modbus.html#ga5">eMBPoll()</a> must be called periodically. The time interval between pooling depends on the configured Modbus timeout. If an RTOS is available a separate task should be created and the task should always call the function <a class="el" href="group__modbus.html#ga5">eMBPoll()</a>.<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Initialize protocol stack in RTU mode for a slave with address 10 = 0x0A</span>
 <a class="code" href="group__modbus.html#ga0">eMBInit</a>( <a class="code" href="group__modbus.html#gga9a1">MB_RTU</a>, 0x0A, 38400, <a class="code" href="group__modbus.html#gga12a9">MB_PAR_EVEN</a> );
 <span class="comment">// Enable the Modbus Protocol Stack.</span>
 <a class="code" href="group__modbus.html#ga3">eMBEnable</a>(  );
 <span class="keywordflow">for</span>( ;; )
 {
     <span class="comment">// Call the main polling loop of the Modbus protocol stack.</span>
     <a class="code" href="group__modbus.html#ga5">eMBPoll</a>(  );
     ...
 }
</pre></div> 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga8">MB_TCP_PORT_USE_DEFAULT</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga9">eMBMode</a> { <a class="el" href="group__modbus.html#gga9a1">MB_RTU</a>, 
<a class="el" href="group__modbus.html#gga9a2">MB_ASCII</a>, 
<a class="el" href="group__modbus.html#gga9a3">MB_TCP</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga10">eMBRegisterMode</a> { <a class="el" href="group__modbus.html#gga10a4">MB_REG_READ</a>, 
<a class="el" href="group__modbus.html#gga10a5">MB_REG_WRITE</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__modbus.html#gga11a6">MB_ENOERR</a>, 
<a class="el" href="group__modbus.html#gga11a7">MB_ENOREG</a>, 
<a class="el" href="group__modbus.html#gga11a8">MB_EINVAL</a>, 
<a class="el" href="group__modbus.html#gga11a9">MB_EPORTERR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__modbus.html#gga11a10">MB_ENORES</a>, 
<a class="el" href="group__modbus.html#gga11a11">MB_EIO</a>, 
<a class="el" href="group__modbus.html#gga11a12">MB_EILLSTATE</a>, 
<a class="el" href="group__modbus.html#gga11a13">MB_ETIMEDOUT</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga12">eMBParity</a> { <a class="el" href="group__modbus.html#gga12a7">MB_PAR_NONE</a>, 
<a class="el" href="group__modbus.html#gga12a8">MB_PAR_ODD</a>, 
<a class="el" href="group__modbus.html#gga12a9">MB_PAR_EVEN</a>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga0">eMBInit</a> (<a class="el" href="group__modbus.html#ga9">eMBMode</a> eMode, UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, <a class="el" href="group__modbus.html#ga12">eMBParity</a> eParity)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga1">eMBTCPInit</a> (USHORT usTCPPort)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga2">eMBClose</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga3">eMBEnable</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga4">eMBDisable</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga5">eMBPoll</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga6">eMBSetSlaveID</a> (UCHAR ucSlaveID, BOOL xIsRunning, UCHAR const *pucAdditional, USHORT usAdditionalLen)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus.html#ga7">eMBRegisterCB</a> (UCHAR ucFunctionCode, pxMBFunctionHandler pxHandler)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ga8" doxytag="mb.h::MB_TCP_PORT_USE_DEFAULT"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define MB_TCP_PORT_USE_DEFAULT&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Use the default Modbus TCP port (502). 
<p>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="MCF5235TCP_2demo_8c-example.html#a63">MCF5235TCP/demo.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a107">STR71XTCP/demo.c</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a140">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ga11" doxytag="mb.h::eMBErrorCode"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__modbus.html#ga11">eMBErrorCode</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Errorcodes used by all function in the protocol stack. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga11a6" doxytag="MB_ENOERR"></a>MB_ENOERR</em>&nbsp;</td><td>
no error. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga11a7" doxytag="MB_ENOREG"></a>MB_ENOREG</em>&nbsp;</td><td>
illegal register address. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga11a8" doxytag="MB_EINVAL"></a>MB_EINVAL</em>&nbsp;</td><td>
illegal argument. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga11a9" doxytag="MB_EPORTERR"></a>MB_EPORTERR</em>&nbsp;</td><td>
porting layer error. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga11a10" doxytag="MB_ENORES"></a>MB_ENORES</em>&nbsp;</td><td>
insufficient resources. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga11a11" doxytag="MB_EIO"></a>MB_EIO</em>&nbsp;</td><td>
I/O error. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga11a12" doxytag="MB_EILLSTATE"></a>MB_EILLSTATE</em>&nbsp;</td><td>
protocol stack in illegal state. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga11a13" doxytag="MB_ETIMEDOUT"></a>MB_ETIMEDOUT</em>&nbsp;</td><td>
timeout error occurred. </td></tr>
</table>
</dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AT91SAM7X__ROWLEY_2demo_8c-example.html#a5">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a15">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a38">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a47">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a61">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a77">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a97">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a105">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a130">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a146">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="mb.h::eMBMode"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__modbus.html#ga9">eMBMode</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Modbus serial transmission modes (RTU/ASCII). 
<p>
Modbus serial supports two transmission modes. Either ASCII or RTU. RTU is faster but has more hardware requirements and requires a network with a low jitter. ASCII is slower and more reliable on slower links (E.g. modems) <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga9a1" doxytag="MB_RTU"></a>MB_RTU</em>&nbsp;</td><td>
RTU transmission mode. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga9a2" doxytag="MB_ASCII"></a>MB_ASCII</em>&nbsp;</td><td>
ASCII transmission mode. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga9a3" doxytag="MB_TCP"></a>MB_TCP</em>&nbsp;</td><td>
TCP mode. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="mbport.h::eMBParity"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__modbus.html#ga12">eMBParity</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Parity used for characters in serial mode. 
<p>
The parity which should be applied to the characters sent over the serial link. Please note that this values are actually passed to the porting layer and therefore not all parity modes might be available. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga12a7" doxytag="MB_PAR_NONE"></a>MB_PAR_NONE</em>&nbsp;</td><td>
No parity. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga12a8" doxytag="MB_PAR_ODD"></a>MB_PAR_ODD</em>&nbsp;</td><td>
Odd parity. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga12a9" doxytag="MB_PAR_EVEN"></a>MB_PAR_EVEN</em>&nbsp;</td><td>
Even parity. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="mb.h::eMBRegisterMode"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__modbus.html#ga10">eMBRegisterMode</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If register should be written or read. 
<p>
This value is passed to the callback functions which support either reading or writing register values. Writing means that the application registers should be updated and reading means that the modbus protocol stack needs to know the current register values.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__modbus__registers.html#ga1">eMBRegHoldingCB( )</a>, <a class="el" href="group__modbus__registers.html#ga2">eMBRegCoilsCB( )</a>, <a class="el" href="group__modbus__registers.html#ga3">eMBRegDiscreteCB( )</a> and <a class="el" href="group__modbus__registers.html#ga0">eMBRegInputCB( )</a>. </dd></dl>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga10a4" doxytag="MB_REG_READ"></a>MB_REG_READ</em>&nbsp;</td><td>
Read register values and pass to protocol stack. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga10a5" doxytag="MB_REG_WRITE"></a>MB_REG_WRITE</em>&nbsp;</td><td>
Update register values. </td></tr>
</table>
</dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AT91SAM7X__ROWLEY_2demo_8c-example.html#a10">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a26">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a42">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a58">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a72">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a87">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a102">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a116">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a134">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a150">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga2" doxytag="mb.h::eMBClose"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBClose           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release resources used by the protocol stack. 
<p>
This function disables the Modbus protocol stack and release all hardware resources. It must only be called when the protocol stack is disabled.<p>
<dl compact><dt><b>Note:</b></dt><dd>Note all ports implement this function. A port which wants to get an callback must define the macro MB_PORT_HAS_CLOSE to 1.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>If the resources where released it return <a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a>. If the protocol stack is not in the disabled state it returns <a class="el" href="group__modbus.html#gga11a12">eMBErrorCode::MB_EILLSTATE</a>. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="LINUX_2demo_8c-example.html#a34">LINUX/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a68">MCF5235TCP/demo.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a112">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a126">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a142">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="mb.h::eMBDisable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBDisable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disable the Modbus protocol stack. 
<p>
This function disables processing of Modbus frames.<p>
<dl compact><dt><b>Returns:</b></dt><dd>If the protocol stack has been disabled it returns <a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a>. If it was not in the enabled state it returns <a class="el" href="group__modbus.html#gga11a12">eMBErrorCode::MB_EILLSTATE</a>. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="LINUX_2demo_8c-example.html#a37">LINUX/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a67">MCF5235TCP/demo.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a111">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a129">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a145">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="mb.h::eMBEnable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBEnable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable the Modbus protocol stack. 
<p>
This function enables processing of Modbus frames. Enabling the protocol stack is only possible if it is in the disabled state.<p>
<dl compact><dt><b>Returns:</b></dt><dd>If the protocol stack is now in the state enabled it returns <a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a>. If it was not in the disabled state it return <a class="el" href="group__modbus.html#gga11a12">eMBErrorCode::MB_EILLSTATE</a>. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AT91SAM7X__ROWLEY_2demo_8c-example.html#a3">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a20">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a35">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a52">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a65">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a82">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a95">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a109">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a127">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a143">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="mb.h::eMBInit"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBInit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga9">eMBMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>eMode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>ucSlaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>ucPort</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ulBaudRate</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__modbus.html#ga12">eMBParity</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>eParity</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the Modbus protocol stack. 
<p>
This functions initializes the ASCII or RTU module and calls the init functions of the porting layer to prepare the hardware. Please note that the receiver is still disabled and no Modbus frames are processed until <a class="el" href="group__modbus.html#ga3">eMBEnable( )</a> has been called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eMode</em>&nbsp;</td><td>If ASCII or RTU mode should be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ucSlaveAddress</em>&nbsp;</td><td>The slave address. Only frames sent to this address or to the broadcast address are processed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ucPort</em>&nbsp;</td><td>The port to use. E.g. 1 for COM1 on windows. This value is platform dependent and some ports simply choose to ignore it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ulBaudRate</em>&nbsp;</td><td>The baudrate. E.g. 19200. Supported baudrates depend on the porting layer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eParity</em>&nbsp;</td><td>Parity used for serial transmission.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If no error occurs the function returns <a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a>. The protocol is then in the disabled state and ready for activation by calling <a class="el" href="group__modbus.html#ga3">eMBEnable( )</a>. Otherwise one of the following error codes is returned:<ul>
<li><a class="el" href="group__modbus.html#gga11a8">eMBErrorCode::MB_EINVAL</a> If the slave address was not valid. Valid slave addresses are in the range 1 - 247.</li><li><a class="el" href="group__modbus.html#gga11a9">eMBErrorCode::MB_EPORTERR</a> IF the porting layer returned an error. </li></ul>
</dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AT91SAM7X__ROWLEY_2demo_8c-example.html#a0">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a16">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a29">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a48">MCF5235/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a78">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a92">STR71X/simple2.c</a>, and <a class="el" href="WIN32_2demo_8cpp-example.html#a121">WIN32/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="mb.h::eMBPoll"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBPoll           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The main pooling loop of the Modbus protocol stack. 
<p>
This function must be called periodically. The timer interval required is given by the application dependent Modbus slave timeout. Internally the function calls xMBPortEventGet() and waits for an event from the receiver or transmitter state machines.<p>
<dl compact><dt><b>Returns:</b></dt><dd>If the protocol stack is not in the enabled state the function returns <a class="el" href="group__modbus.html#gga11a12">eMBErrorCode::MB_EILLSTATE</a>. Otherwise it returns <a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a>. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AT91SAM7X__ROWLEY_2demo_8c-example.html#a4">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a21">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a36">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a53">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a66">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a83">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a96">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a110">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a128">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a144">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="mb.h::eMBRegisterCB"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBRegisterCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">UCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>ucFunctionCode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>pxMBFunctionHandler&nbsp;</td>
          <td class="mdname" nowrap> <em>pxHandler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Registers a callback handler for a given function code. 
<p>
This function registers a new callback handler for a given function code. The callback handler supplied is responsible for interpreting the Modbus PDU and the creation of an appropriate response. In case of an error it should return one of the possible Modbus exceptions which results in a Modbus exception frame sent by the protocol stack.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ucFunctionCode</em>&nbsp;</td><td>The Modbus function code for which this handler should be registers. Valid function codes are in the range 1 to 127. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pxHandler</em>&nbsp;</td><td>The function handler which should be called in case such a frame is received. If <code>NULL</code> a previously registered function handler for this function code is removed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a> if the handler has been installed. If no more resources are available it returns <a class="el" href="group__modbus.html#gga11a10">eMBErrorCode::MB_ENORES</a>. In this case the values in <a class="el" href="mbconfig_8h.html">mbconfig.h</a> should be adjusted. If the argument was not valid it returns <a class="el" href="group__modbus.html#gga11a8">eMBErrorCode::MB_EINVAL</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="mb.h::eMBSetSlaveID"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBSetSlaveID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">UCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>ucSlaveID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>BOOL&nbsp;</td>
          <td class="mdname" nowrap> <em>xIsRunning</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UCHAR const *&nbsp;</td>
          <td class="mdname" nowrap> <em>pucAdditional</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>USHORT&nbsp;</td>
          <td class="mdname" nowrap> <em>usAdditionalLen</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Configure the slave id of the device. 
<p>
This function should be called when the Modbus function <em>Report Slave ID</em> is enabled ( By defining MB_FUNC_OTHER_REP_SLAVEID_ENABLED in <a class="el" href="mbconfig_8h.html">mbconfig.h</a> ).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ucSlaveID</em>&nbsp;</td><td>Values is returned in the <em>Slave ID</em> byte of the <em>Report Slave ID</em> response. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xIsRunning</em>&nbsp;</td><td>If TRUE the <em>Run Indicator Status</em> byte is set to 0xFF. otherwise the <em>Run Indicator Status</em> is 0x00. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pucAdditional</em>&nbsp;</td><td>Values which should be returned in the <em>Additional</em> bytes of the <em> Report Slave ID</em> response. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usAdditionalLen</em>&nbsp;</td><td>Length of the buffer <code>pucAdditonal</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If the static buffer defined by MB_FUNC_OTHER_REP_SLAVEID_BUF in <a class="el" href="mbconfig_8h.html">mbconfig.h</a> is to small it returns <a class="el" href="group__modbus.html#gga11a10">eMBErrorCode::MB_ENORES</a>. Otherwise it returns <a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a>. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="AVR_2demo_8c-example.html#a19">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a33">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a51">MCF5235/demo.c</a>, and <a class="el" href="WIN32_2demo_8cpp-example.html#a125">WIN32/demo.cpp</a>.</dl>    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="mb.h::eMBTCPInit"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__modbus.html#ga11">eMBErrorCode</a> eMBTCPInit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">USHORT&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>usTCPPort</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the Modbus protocol stack for Modbus TCP. 
<p>
This function initializes the Modbus TCP Module. Please note that frame processing is still disabled until <a class="el" href="group__modbus.html#ga3">eMBEnable( )</a> is called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usTCPPort</em>&nbsp;</td><td>The TCP port to listen on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If the protocol stack has been initialized correctly the function returns <a class="el" href="group__modbus.html#gga11a6">eMBErrorCode::MB_ENOERR</a>. Otherwise one of the following error codes is returned:<ul>
<li><a class="el" href="group__modbus.html#gga11a8">eMBErrorCode::MB_EINVAL</a> If the slave address was not valid. Valid slave addresses are in the range 1 - 247.</li><li><a class="el" href="group__modbus.html#gga11a9">eMBErrorCode::MB_EPORTERR</a> IF the porting layer returned an error. </li></ul>
</dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="MCF5235TCP_2demo_8c-example.html#a62">MCF5235TCP/demo.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a106">STR71XTCP/demo.c</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a139">WIN32TCP/demo.cpp</a>.</dl>    </td>
  </tr>
</table>

<hr width="80%">
<p><center>Automatically generated by Doxygen 1.4.2 on 13 Sep 2018.</center></p>

</body>
</html>
